const Discord = require("discord.js");
const {
  REST,
  Routes,
  SlashCommandBuilder,
  ApplicationCommandOptionType,
} = require("discord.js");
const axios = require("axios");
const FormData = require("form-data");
const express = require("express");
const {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  PermissionsBitField,
  //  StringSelectMenuBuilder,
  //  StringSelectMenuInteraction,
  //  AttachmentBuilder,
  Partials,
} = require("discord.js");
const events = require("events");
events.EventEmitter.defaultMaxListeners = 15;

// Xu·∫•t h√†m
const { sendEmo } = require("./sendEmo");
const registerHelpCommand = require("./helpembed.js");
const handleCooldown = require("./cooldown");
const loadFileContents = require("./xacdinhtxt");
const { getRandomWaifuImage } = require("./anhwaifu");
const setBotStatus = require("./trangthaibot");

// x·ª≠ l√Ω nh·∫°c
const {
  AudioPlayerStatus,
  createAudioPlayer,
  createAudioResource,
  NoSubscriberBehavior,
  joinVoiceChannel,
} = require("@discordjs/voice");
const fs = require("fs");
const ytdl = require("@distube/ytdl-core");
const { google } = require("googleapis");
const youtube = google.youtube("v3");
const youtubeSearch = require("youtube-search");

//___
var ActiveMessage = true;

const app = express();
//___
const client = new Discord.Client({
  intents: [
    "Guilds",
    "GuildMessages",
    "GuildMembers",
    "MessageContent",
    "GuildVoiceStates",
    "GuildPresences",
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction],
});
registerHelpCommand(client);
setBotStatus(client);

//___
const folderPath = "text";
const fileContents = loadFileContents(folderPath);

//___id k√™nh sendemoji
const allowedChannel = ["1269625880272044042", "", ""];
//___quy·ªÅn id l·ªánh administrator
const allowedUserIds = [
  "958668688607838208",
  "712642371669458964",
  "891486418872963092",
  "816890629581570058",
  "804347438881570836",
  "1091723343713021962",
];

//___id quy·ªÅn l·ªçc ch·ª≠i th·ªÅ v√† spam
/*
const allowedUserIds2 = ["",
 "",
 "",
 "",
 "",
]; // t·∫°m d·ª´ng
*/

app.listen(3000, () => {
  console.log("An Pahn Online ‚úÖ");
  client.uptimeStart = Date.now();
});
app.get("/", (req, res) => {
  res.send("Bot By Pahn An - Version v3.0.0");
});

client.on("messageCreate", (message) => {
  if (message.content === "ping") {
    message.channel.send("pong!");
  }
  sendEmo(message, allowedChannel);
  if (ActiveMessage) handleCooldown(message, fileContents);
});

//___
client.on("messageCreate", async (message) => {
  if (message.content === "!ping") {
    const apiLatency = Math.round(client.ws.ping);
    const botLatency = Date.now() - message.createdTimestamp;

    const embed = new EmbedBuilder()
      .setColor("00FF00")
      .setTitle("üì∂ ·¥ò…™…¥…¢  ô·¥è·¥õ")
      .setDescription("pong!")
      .addFields(
        { name: "ƒê·ªô ·¥õ Ä·ªÖ  ô·¥è·¥õ:", value: `${botLatency} ·¥çs` },
        { name: "ƒê·ªô ·¥õ Ä·ªÖ ·¥Ä·¥ò…™:", value: `${apiLatency} ·¥çs` },
      )
      .setThumbnail(client.user.displayAvatarURL())
      .setTimestamp();

    await message.channel.send({ embeds: [embed] });
  }
});

//___
client.on("ready", () => {
  ActiveSlash();
});

function ActiveSlash() {
  try {
    var rest = new Discord.REST({ version: "10" }).setToken(process.env.token);

    const commands = [
      {
        name: "txt",
        description: " ô·∫≠·¥õ/·¥õ·∫Ø·¥õ ·¥õ Ä·∫£  ü·ªù…™ ·¥õ…™…¥ …¥ ú·∫Ø…¥ ·¥õx·¥õ.",
        options: [],
      },
      {
        name: "help",
        description: " ú…™·ªá…¥ ·¥õ·∫•·¥õ ·¥Ñ·∫£ ·¥Ñ√°·¥Ñ  ü·ªá…¥ ú  ô·∫°…¥ ·¥Ñ√≥ ·¥õ ú·ªÉ ·¥Ö√π…¥…¢.",
        options: [],
      },
      {
        name: "dungbot",
        description: "·¥õ·∫Ø·¥õ  ô·¥è·¥õ ! ·¥Ä…¥ ·¥ò·¥Ä ú…¥.",
        options: [],
      },
      {
        name: "nasa",
        description: " ú…™·ªÉ·¥ç ·¥õ ú·ªã  ú√¨…¥ ú ·∫£…¥ ú ·¥õ ú…™√™…¥ ·¥†ƒÉ…¥  ú·ªç·¥Ñ ·¥õ·¥ú è·ªá·¥õ ƒë·∫π·¥ò ·¥ç·ªó…™ …¥…¢√† è.",
        options: [],
      },
      {
        name: "quetpl",
        description: "«´·¥ú√©·¥õ ·¥†…™ Ä·¥ús “ì…™ ü·¥á ·¥ò ü·¥ú…¢…™…¥s ·¥Ö·∫°…¥…¢ (.·¥ä·¥Ä Ä).",
        options: [
          {
            name: "plugin",
            description: "·¥õ ú√™·¥ç “ì…™ ü·¥á ·¥ò ü·¥ú…¢…™…¥s ·¥Ö·∫°…¥…¢ (.·¥ä·¥Ä Ä) ƒë·ªÉ «´·¥ú√©·¥õ.",
            type: Discord.ApplicationCommandOptionType.Attachment,
            required: true,
          },
        ],
      },
      {
        name: "quetlink",
        description: "·¥ã…™·ªÉ·¥ç ·¥õ Ä·¥Ä ·¥ç·ª©·¥Ñ ƒë·ªô ·¥Ä…¥ ·¥õ·¥è√†…¥ ·¥Ñ·ªß·¥Ä ·¥°·¥á ôs…™·¥õ·¥á.",
        options: [
          {
            name: "url",
            description: "·¥õ ú√™·¥ç ·¥ú Ä ü ·¥Ö·∫°…¥…¢ ( ú·¥õ·¥õ·¥òs://) ƒë·ªÉ «´·¥ú√©·¥õ.",
            type: Discord.ApplicationCommandOptionType.String,
            required: true,
          },
        ],
      },
      {
        name: "avatar",
        description: " ú…™·ªÉ…¥ ·¥õ ú·ªã ·¥Ä·¥†·¥Ä·¥õ·¥Ä Ä ·¥Ñ·ªß·¥Ä …¥…¢∆∞·ªù…™ ·¥Ö√π…¥…¢.",
        options: [
          {
            name: "user",
            description: "·¥Ñ ú·ªç…¥ <@·¥ç·¥á…¥·¥õ…™·¥è…¥>/<…™·¥Ö> ƒë·ªÉ  ü·∫• è ·¥Ä·¥†·¥Ä·¥õ·¥Ä Ä.",
            type: Discord.ApplicationCommandOptionType.User,
            required: false,
          },
        ],
      },
      {
        name: "anhwaifu",
        description: " Ä·¥Ä…¥·¥Ö·¥è·¥ç ·∫£…¥ ú ·¥Ä…¥…™·¥ç·¥á …¥…¢·∫´·¥ú …¥ ú…™√™…¥ ·¥õ·∫∑…¥…¢  ô·∫°…¥.",
        options: [],
      },
      {
        name: "riengwaifu",
        description: " Ä·¥Ä…¥·¥Ö·¥è·¥ç …¥…¢·∫´·¥ú …¥ ú…™√™…¥ ·∫£…¥ ú ·¥Ä…¥…™·¥ç·¥á ·¥†√† …¢·ª≠…™  Ä…™√™…¥…¢ ·¥Ñ ú·¥è  ô·∫°…¥.",
        options: [],
      },
      {
        name: "server",
        description: "·¥ã…™·ªÉ·¥ç ·¥õ Ä·¥Ä ·¥õ ú√¥…¥…¢ ·¥õ…™…¥ ·¥Ñ·ªß·¥Ä s·¥á Ä·¥†·¥á Ä ·¥ç…™…¥·¥á·¥Ñ Ä·¥Ä“ì·¥õ.",
        options: [
          {
            name: "ip",
            description: "…¥ ú·∫≠·¥ò …™·¥ò s·¥á Ä·¥†·¥á Ä ·¥ç…™…¥·¥á·¥Ñ Ä·¥Ä“ì·¥õ ƒë·ªÉ ·¥ã…™·ªÉ·¥ç ·¥õ Ä·¥Ä.",
            type: Discord.ApplicationCommandOptionType.String,
            required: true,
          },
        ],
      },
      {
        name: "check",
        description: "·¥Ñ ú·¥á·¥Ñ·¥ã  ô·∫£·¥è ·¥ç·∫≠·¥õ ·¥ç√° è ·¥Ñ ú·ªß ·¥Ö…™s·¥Ñ·¥è Ä·¥Ö.",
        options: [
          {
            name: "id",
            description: "…¥ ú·∫≠·¥ò …™·¥Ö ·¥ç√° è ·¥Ñ ú·ªß  ô·¥è·¥õ ƒë·¥Ä…¥…¢ ·ªü ƒë·ªÉ ·¥Ñ ú·¥á·¥Ñ·¥ã.",
            type: Discord.ApplicationCommandOptionType.String,
            required: false,
          },
        ],
      },
      {
        name: "info",
        description: "Hi·ªÉm th·ªã th√¥ng tin c·ªßa b·∫°n.",
        options: [
          {
            name: "user",
            description: "·¥Ñ ú·ªç…¥ <@·¥ç·¥á…¥·¥õ…™·¥è…¥>/<…™·¥Ö> ƒë·ªÉ  ü·∫• è th√¥ng tin.",
            type: Discord.ApplicationCommandOptionType.User,
            required: false,
          },
        ],
      },
    ];
    rest
      .put(Discord.Routes.applicationCommands(client.user.id), {
        body: commands,
      })
      .catch(console.error);
  } catch (e) {
    console.error(e);
  }
}
//___

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  if (interaction.commandName === "txt") {
    const userId = interaction.user.id;
    if (allowedUserIds.includes(userId)) {
      ActiveMessage = !ActiveMessage;

      const statusEmbed = new EmbedBuilder()
        .setColor(ActiveMessage ? "#00ff00" : "#ff0000")
        .setDescription(`·¥õ…™…¥ …¥ ú·∫Ø…¥ ·¥õ·ª± ƒë·ªô…¥…¢: ${ActiveMessage ? " ô·∫≠·¥õ" : "·¥õ·∫Ø·¥õ"}`);

      await interaction.reply({ embeds: [statusEmbed] });
    } else {
      const noPermissionEmbed = new EmbedBuilder()
        .setColor("#ff0000")
        .setTitle("‚ö†Ô∏è «´·¥ú è·ªÅ…¥  ú·∫°…¥ ·¥ã ú√¥…¥…¢ ƒë·ªß ‚ö†Ô∏è")
        .setDescription("‚ùé  ô·∫°…¥ ·¥ã ú√¥…¥…¢ ·¥Ñ√≥ «´·¥ú è·ªÅ…¥ s·ª≠ ·¥Ö·ª•…¥…¢  ü·ªá…¥ ú …¥√† è.");

      await interaction.reply({ embeds: [noPermissionEmbed] });
    }
  }
});
//___

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  const { commandName, user } = interaction;

  if (commandName === "dungbot") {
    if (!allowedUserIds.includes(user.id)) {
      const noPermissionEmbed = new EmbedBuilder()
        .setColor("#ff0000")
        .setTitle("‚ö†Ô∏è «´·¥ú è·ªÅ…¥  ú·∫°…¥ ·¥ã ú√¥…¥…¢ ƒë·ªß ‚ö†Ô∏è")
        .setDescription("‚ùé  ô·∫°…¥ ·¥ã ú√¥…¥…¢ ·¥Ñ√≥ «´·¥ú è·ªÅ…¥ s·ª≠ ·¥Ö·ª•…¥…¢  ü·ªá…¥ ú …¥√† è.");

      await interaction.reply({
        embeds: [noPermissionEmbed],
        ephemeral: true,
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setTitle("·¥õ ú√¥…¥…¢  ô√°·¥è ·¥Ñ·∫≠·¥ò …¥ ú·∫≠·¥õ  ô·¥è·¥õ ü§ñ")
      .setDescription(
        "‚Ä¢  ô·¥è·¥õ  ú…™·ªá…¥ ·¥õ·∫°…™ ƒë·¥Ä…¥…¢ ·¥Ö·ª´…¥…¢  ú·¥è·∫°·¥õ ƒë·ªô…¥…¢ üîí \n‚Ä¢  ô·¥è·¥õ s·∫Ω  ú·¥è·∫°·¥õ ƒë·ªô…¥…¢  ü·∫°…™ s·¥Ä·¥ú ·¥ã ú…™ «´·¥ú√° ·¥õ Ä√¨…¥ ú ·¥Ñ·∫≠·¥ò …¥ ú·∫≠·¥õ  ú·¥è√†…¥ ·¥õ·∫•·¥õ üîì",
      )
      .setColor("#ff0000")
      .setFooter({ text: "¬© ·¥Ñ·¥è·¥Ö·¥á  ô è ·¥Ä…¥ ·¥ò·¥Ä ú…¥ üêß" })
      .setImage("https://share.creavite.co/667fa87da4acd93e52346f5a.gif")
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
    process.exit();
  }
});

//___
client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  if (interaction.commandName === "avatar") {
    const user = interaction.options.getUser("user") || interaction.user;
    let format = user.displayAvatarURL().includes(".gif") ? "gif" : "png";

    const avatarURL = user.displayAvatarURL({ format, size: 1024 });

    const embed = new EmbedBuilder()
      .setTitle(`·¥Ä·¥†·¥Ä·¥õ·¥Ä Ä ·¥Ñ·ªß·¥Ä: ${user.tag}`)
      .setDescription(`[ ü…™…¥·¥ã ·¥Ä·¥†·¥Ä·¥õ·¥Ä Ä:](${avatarURL})`)
      .setImage(avatarURL)
      .setColor("#2e3b46")
      .setFooter({
        text: ` è√™·¥ú ·¥Ñ·∫ß·¥ú  ô·ªü…™: ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL({ dynamic: true }),
      });

    await interaction.reply({ embeds: [embed] });
  }
});
//___

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  const { commandName } = interaction;

  if (commandName === "anhwaifu") {
    const imageUrl = await getRandomWaifuImage();
    if (!imageUrl) {
      await interaction.reply("ƒê√£  ô·ªã  ü·ªó…™, ·¥ã ú√¥…¥…¢ ·¥õ ú·ªÉ  ü·∫• è ·∫£…¥ ú!");
      return;
    }

    const embed = new EmbedBuilder()
      .setTitle("·∫¢…¥ ú ·¥°·¥Ä…™“ì·¥ú …¥…¢·∫´·¥ú …¥ ú…™√™…¥:")
      .setImage(imageUrl)
      .setColor("#FFC0CB")
      .setFooter({
        text: ` è√™·¥ú ·¥Ñ·∫ß·¥ú  ô·ªü…™: ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL({ dynamic: true }),
      })
      .setTimestamp();

    await interaction.reply({ embeds: [embed] });
  }

  if (commandName === "riengwaifu") {
    const imageUrl = await getRandomWaifuImage();
    if (!imageUrl) {
      await interaction.reply("ƒê√£  ô·ªã  ü·ªó…™, ·¥ã ú√¥…¥…¢ ·¥õ ú·ªÉ  ü·∫• è ·∫£…¥ ú!");
      return;
    }

    const embed = new EmbedBuilder()
      .setTitle("·∫¢…¥ ú ·¥°·¥Ä…™“ì·¥ú …¥…¢·∫´·¥ú …¥ ú…™√™…¥:")
      .setImage(imageUrl)
      .setColor("#FFC0CB")
      .setFooter({
        text: ` è√™·¥ú ·¥Ñ·∫ß·¥ú  ô·ªü…™: ${interaction.user.tag}`,
        iconURL: interaction.user.displayAvatarURL({ dynamic: true }),
      })
      .setTimestamp();

    try {
      await interaction.user.send({
        content: "ƒê√¢ è  ü√† ·∫£…¥ ú …¥…¢·∫´·¥ú …¥ ú…™√™…¥  Ä…™√™…¥…¢ ·¥õ∆∞ ·¥Ñ·ªß·¥Ä  ô·∫°…¥:",
        embeds: [embed],
      });

      const replyEmbed = new EmbedBuilder()
        .setDescription(
          "·∫¢…¥ ú …¥…¢·∫´·¥ú …¥ ú…™√™…¥ ƒë√£ ƒë∆∞·ª£·¥Ñ …¢·ª≠…™ ƒë·∫ø…¥ ·¥õ…™…¥ …¥ ú·∫Ø…¥  Ä…™√™…¥…¢ ·¥õ∆∞ ·¥Ñ·ªß·¥Ä  ô·∫°…¥  ú√£ è ·¥Ñ ú·¥á·¥Ñ·¥ã ·¥õ…™…¥ …¥ ú·∫Ø…¥ …¥ ú√©.",
        )
        .setColor("#00ff00");

      await interaction.reply({ embeds: [replyEmbed], ephemeral: true });
    } catch (error) {
      await interaction.reply(
        "·¥ã ú√¥…¥…¢ ·¥õ ú·ªÉ …¢·ª≠…™ ·¥õ…™…¥ …¥ ú·∫Ø…¥  Ä…™√™…¥…¢ ·¥õ∆∞. ·¥†·¥ú…™  ü√≤…¥…¢ ·¥ã…™·ªÉ·¥ç ·¥õ Ä·¥Ä ·¥Ñ√†…™ ƒë·∫∑·¥õ «´·¥ú è·ªÅ…¥  Ä…™√™…¥…¢ ·¥õ∆∞ ·¥Ñ·ªß·¥Ä  ô·∫°…¥.",
        { ephemeral: true },
      );
    }
  }
});
//___

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  if (interaction.commandName === "server") {
    await interaction.deferReply();
    const serverName = interaction.options.getString("ip");

    try {
      const response = await axios.get(
        `https://api.mcsrvstat.us/2/${serverName}`,
      );
      const data = await response.data;

      if (data.online) {
        const embed = new EmbedBuilder()
          .setDescription(`s·¥á Ä·¥†·¥á Ä: **${serverName}**`)
          .addFields(
            {
              name: "‚Ä¢ ·¥õ Ä·∫°…¥…¢ ·¥õ ú√°…™:",
              value: data.online ? " ú·¥è·∫°·¥õ ƒë·ªô…¥…¢" : "·¥ã ú√¥…¥…¢  ú·¥è·∫°·¥õ ƒë·ªô…¥…¢",
            },
            { name: "‚Ä¢ …™·¥ò ·¥Ä·¥Ö·¥Ö Ä·¥áss:", value: data.ip || "·¥ã ú√¥…¥…¢ ·¥Ñ√≥ ·¥õ ú√¥…¥…¢ ·¥õ…™…¥" },
            {
              name: "‚Ä¢ ·¥ò·¥è Ä·¥õ s·¥á Ä·¥†·¥á Ä:",
              value: data.port.toString() || "·¥ã ú√¥…¥…¢ ·¥Ñ√≥ ·¥õ ú√¥…¥…¢ ·¥õ…™…¥",
            },
            {
              name: "‚Ä¢ …¥…¢∆∞·ªù…™ ·¥Ñ ú∆°…™:",
              value: `${data.players.online} / ${data.players.max}`,
            },
            {
              name: "‚Ä¢ ·¥ò ú…™√™…¥  ô·∫£…¥:",
              value: data.version || "·¥ã ú√¥…¥…¢ ·¥Ñ√≥ ·¥õ ú√¥…¥…¢ ·¥õ…™…¥",
            },
            {
              name: "‚Ä¢ ·¥ç√¥ ·¥õ·∫£:",
              value: data.motd.clean.join("\n") || "·¥ã ú√¥…¥…¢ ·¥Ñ√≥ ·¥õ ú√¥…¥…¢ ·¥õ…™…¥",
            },
          )
          .setThumbnail(`https://api.mcsrvstat.us/icon/${serverName}`)
          .setColor("#00ff00")
          .setFooter({ text: "¬© ·¥Ñ·¥è·¥Ö·¥á  ô è ·¥Ä…¥ ·¥ò·¥Ä ú…¥ üêß" });

        await interaction.editReply({ embeds: [embed] });
      } else {
        const embed = new EmbedBuilder()
          .setDescription(
            `s·¥á Ä·¥†·¥á Ä **${serverName}** …¥√† è ·¥ã ú√¥…¥…¢  ú·¥è·∫°·¥õ ƒê·ªô…¥…¢  ú·¥è·∫∑·¥Ñ ·¥ã ú√¥…¥…¢ ·¥õ·ªì…¥ ·¥õ·∫°…™!`,
          )
          .setColor("#ff0000");

        await interaction.editReply({ embeds: [embed] });
      }
    } catch (error) {
      const embed = new EmbedBuilder()
        .setDescription(" ü·ªó…™ ·¥ã ú…™  ü·∫• è ·¥õ ú√¥…¥…¢ ·¥õ…™…¥ ·¥Ñ·ªß·¥Ä s·¥á Ä·¥†·¥á Ä!.")
        .setColor("#ff0000");

      await interaction.editReply({ embeds: [embed] });
    }
  }
});
//___

// T·∫°m d·ª´ng
/*
const WARNING_CHANNEL_ID = ''; // id k√™nh xem log

const antiSpam = new Map();
const spamTracker = new Map();
const SPAM_THRESHOLD = 5;
const SPAM_DURATION = 10000;
const RESET_DURATION = 30000; // 30 gi√¢y

const PROFANITY = ["cl",
  "cc",
  "c·∫∑c",
  "ƒë√©o",
  "dume",
  "ƒë·ª• m√°",
  "djt",
  "cailonma",
  "c√°i l·ªìn",
  "l·ªìn",
  "ƒë·ªãt",
  "ƒë·ªãt m·∫π",
  "ƒëjt",
  "motherfucker",
  "bitch",
  "shit",
  "asshole",
  "pussy",
  "whore",
  "slut",
  "dick",
  "cock",
  "nigger",
  "faggot",
  "chink",
  "kike",
  "spic",
  "wetback",
  "cunt",
  "twat",
  "bugger",
  "bollocks",
  "arse",
  "tosser",
  "wanker",
  "bastard",
  "bloody",
  "damn",
  "hell",
  "balls",
  "bullshit",
  "crap",
  "darn",
  "douche",
  "freak",
  "frick",
  "jerk",
  "prick",
  "suck",
  "turd",
  "blowjob",
  "handjob",
  "spank",
  "spunk",
  "poontang",
  "piss",
  "pussyhole",
  "fuckface",
  "shithead",
  "m·∫π ki·∫øp",
  "ƒë·ªì ch√≥",
  "ngu",
  "ch·∫øt ti·ªát",
  "th·∫±ng kh·ªën",
  "ƒëƒ©",
  "b√≤i",
  "b√∫a xua",
  "ba tr·ª£n",
  "d∆° d√°ng",
  "ƒë·ªì r√°c",
  "c√¢m m·ªìm",
  "kh·ªën n·∫°n",
  "con hoang",
  "con l·ª£n",
  "m·∫π m√†y",
  "th·∫±ng ch√≥",
  "v√£i ƒë√°i",
  "v√£i l·ªìn",
  "ƒë·ªì kh·ªën n·∫°n",
  "ƒë·ªì l·ª£n",
  "ƒë·ªì ph·∫£n b·ªôi",
  "ƒë·ªì ngu",
  "m√†y ƒëi√™n √†",
  "ƒë·ªì ƒëƒ©",
  "ƒë·ªì ƒëƒ© th√µa",
  "m·∫•t d·∫°y",
  "ƒë·ªì ch·∫øt ti·ªát",]; // c√°c t·ª´ c·∫ßn l·ªçc v√†o ƒë√¢y

const ALLOWED_WORDS = ["acc",
  "access",
  "account",
  "accurate",
  "hello",
  "accomplish",
  "according",
  "acknowledge",
  "acquire",
  "active",
  "activity",
  "actually",
  "addition",
  "address",
  "adjust",
  "admit",
  "advance",
  "advantage",
  "advertise",
  "advice",
  "advise",
  "affect",
  "afford",
  "after",
  "again",
  "against",
  "age",
  "agency",
  "agent",
  "ago",
  "agree",
  "agreement",
  "ahead",
  "air",
  "all",
  "allow",
  "almost",
  "alone",
  "along",
  "already",
  "also",
  "although",
  "always",
  "amaze",
  "amazing",
  "among",
  "amount",
  "analysis",
  "ancient",
  "and",
  "anger",
  "angle",
  "animal",
  "announce",
  "another",
  "answer",
  "anxiety",
  "any",
  "anybody",
  "anymore",
  "anyone",
  "anything",
  "anyway",
  "apart",
  "apartment",
  "apologize",
  "apparent",
  "appeal",
  "appear",
  "appearance",
  "apple",
  "application",
  "apply",
  "appoint",
  "appointment",
  "appreciate",
  "approach",
  "appropriate",
  "approval",
  "approve",
  "approximate",
  "area",
  "argue",
  "argument",
  "arise",
  "arm",
  "around",
  "arrange",
  "arrangement",
  "arrest",
  "arrival",
  "arrive",
  "art",
  "article",
  "artist",
  "as",
  "aside",
  "ask",
  "asleep",
  "aspect",
  "ass",
  "assemble",
  "assembly",
  "assess",
  "assessment",
  "assign",
  "assignment",
  "assist",
  "assistance",
  "assistant",
  "associate",
  "association",
  "assume",
  "assumption",
  "assure",
  "at",
  "athlete",
  "atmosphere",
  "attach",
  "attack",
  "attempt",
  "attend",
  "attention",
  "attitude",
  "attorney",
  "attract",
  "attraction",
  "attractive",
  "attribute",
  "audience",
  "author",
  "authority",
  "available",
  "average",
  "avoid",
  "award",
  "aware",
  "awareness",
  "away",
  "awful",
  "baby",
  "back",
  "background",
  "bad",
  "badly",
  "bag",
  "balance",
  "ball",
  "ban",
  "band",
  "bank",
  "bar",
  "barely",
  "barrel",
  "base",
  "baseball",
  "basic",
  "basically",
  "basis",
  "basket",
  "basketball",
  "bath",
  "bathroom",
  "battery",
  "battle",
  "be",
  "beach",
  "bean",
  "bear",
  "beat",
  "beautiful",
  "beauty",
  "because",
  "become",
  "bed",
  "bedroom",
  "bee",
  "beef",
  "beer",
  "before",
  "began",
  "begin",
  "beginning",
  "behavior",
  "behind",
  "being",
  "belief",
  "believe",
  "bell",
  "belong",
  "below",
  "belt",
  "bench",
  "bend",
  "benefit",
  "beside",
  "besides",
  "best",
  "bet",
  "better",
  "between",
  "beyond",
  "bicycle",
  "big",
  "bike",
  "bill",
  "billion",
  "bind",
  "biological",
  "bird",
  "birth",
  "birthday",
  "bit",
  "bite",
  "black",
  "blame",
  "blanket",
  "blind",
  "block",
  "blood",
  "blow",
  "blue",
  "board",
  "boat",
  "body",
  "bomb",
  "bond",
  "bone",
  "book",
  "boom",]; // c√°c t·ª´ ko ƒëc l·ªçc

client.on("messageCreate", (message) => {
  if (message.author.bot) return;

  const userId = message.author.id;
  const isAllowedUser = allowedUserIds2.includes(userId);

  if (!antiSpam.has(userId)) {
    antiSpam.set(userId, []);
  }

  const userMessages = antiSpam.get(userId);
  userMessages.push(Date.now());

  const timeFrame = userMessages.filter(
    (timestamp) => Date.now() - timestamp < SPAM_DURATION,
  );

  if (timeFrame.length > SPAM_THRESHOLD && !isAllowedUser) {
    const spamEmbed = new EmbedBuilder()
      .setColor("#ff0000")
      .setTitle("[·¥Ñ·∫£…¥ ú  ô√°·¥è s·¥ò·¥Ä·¥ç]")
      .setDescription(
        `${message.author},  ô·∫°…¥ ƒë·¥Ä…¥…¢ s·¥ò·¥Ä·¥ç, ·¥†·¥ú…™  ü√≤…¥…¢ ·¥Ñ ú·¥Ä·¥õ ·¥Ñ ú·∫≠·¥ç  ü·∫°…™!`,
      )
      .setFooter({ text: "¬© ·¥Ñ·¥è·¥Ö·¥á  ô è ·¥Ä…¥ ·¥ò·¥Ä ú…¥ üêß" })
      .setTimestamp();

    message.channel.send({ embeds: [spamEmbed] }).then((sentMessage) => {
      setTimeout(() => {
        sentMessage.delete().catch((err) => {
          if (err.code !== 10008) {
            console.error(err);
          }
        });
      }, 2000);
    });
    message.delete().catch((err) => {
      if (err.code !== 10008) {
        console.error(err);
      }
    });

    const warningEmbed = new EmbedBuilder()
      .setColor("#ff0000")
      .setTitle("[üîî  ü·¥è…¢ ·¥Ñ·∫¢…¥ ú ·¥Ñ√Å·¥è]")
      .setDescription(`<@${message.author.id}> ƒê√£  ô·ªã ·¥Ñ·∫£…¥ ú ·¥Ñ√°·¥è ·¥†√¨ s·¥ò·¥Ä·¥ç!`)
      .setTimestamp();

    const warningChannel = client.channels.cache.get(WARNING_CHANNEL_ID);
    if (warningChannel) {
      warningChannel.send({ embeds: [warningEmbed] });
    }

    antiSpam.set(userId, timeFrame);

    if (isAllowedUser) {
      spamTracker.set(userId, Date.now());
    }
    return;
  }

  for (const word of PROFANITY) {
    if (
      message.content.toLowerCase().includes(word) &&
      !ALLOWED_WORDS.some((allowedWord) =>
        message.content.toLowerCase().includes(allowedWord),
      ) &&
      !isAllowedUser
    ) {
      message.delete().catch((err) => {
        if (err.code !== 10008) {
          console.error(err);
        }
      });

      const profanityEmbed = new EmbedBuilder()
        .setColor("#ff0000")
        .setTitle("[·¥Ñ·∫£…¥ ú  ô√°·¥è …¥…¢√¥…¥ ·¥õ·ª´]")
        .setDescription(
          `${message.author},  ú√£ è ·¥Ñ ú√∫ √Ω …¥…¢√¥…¥ ·¥õ·ª´,  ô√¨…¥ ú ·¥õƒ©…¥ ú …¥√†·¥è  ô·∫°…¥ ∆°…™!`,
        )
        .setFooter({ text: "¬© ·¥Ñ·¥è·¥Ö·¥á  ô è ·¥Ä…¥ ·¥ò·¥Ä ú…¥ üêß" })
        .setTimestamp();

      message.channel.send({ embeds: [profanityEmbed] }).then((sentMessage) => {
        setTimeout(() => {
          sentMessage.delete().catch((err) => {
            if (err.code !== 10008) {
              console.error(err);
            }
          });
        }, 2000);
      });

      const warningEmbed = new EmbedBuilder()
        .setColor("#ff0000")
        .setTitle("[üîî  ü·¥è…¢ ·¥Ñ·∫¢…¥ ú ·¥Ñ√Å·¥è]")
        .setDescription(`<@${message.author.id}> ƒê√£  ô·ªã ·¥Ñ·∫£…¥ ú ·¥Ñ√°·¥è ·¥†√¨ ·¥Ö√π…¥…¢ …¥…¢√¥…¥ ·¥õ·ª´ ·¥ã ú√¥…¥…¢ ·¥ò ú√π  ú·ª£·¥ò!`)
        .setTimestamp();

      const warningChannel = client.channels.cache.get(WARNING_CHANNEL_ID);
      if (warningChannel) {
        warningChannel.send({ embeds: [warningEmbed] });
      }

      if (isAllowedUser) {
        spamTracker.set(userId, Date.now());
      }
      return;
    }
  }

  if (isAllowedUser && spamTracker.has(userId)) {
    const lastSpamTime = spamTracker.get(userId);
    if (Date.now() - lastSpamTime > RESET_DURATION) {
      antiSpam.set(userId, []);
      spamTracker.delete(userId);
    }
  }
});
*/
//___

const youtubeApiKey = "AIzaSyB5kahXDrdMynCN13IXwoPRG32HIA9Zj28";
//"AIzaSyD6WYgtRPv2CQAYgRX7kpVKJ6-_Pu36nRk";

const queue = [];
let connection = null;
let player = null;
let isPlaying = false;
let isLooping = false;
let idleTimeout = null;
let textChannel = null;
let userRequestedLeave = false;

async function searchYouTube(query) {
  const options = {
    maxResults: 5,
    key: youtubeApiKey,
  };

  const results = await youtubeSearch(query, options);
  return results.results;
}

async function playSpecificSong(youtubeUrl) {
  if (!connection) {
    const userVoiceChannel = textChannel.guild.members.me.voice.channel;
    if (userVoiceChannel) {
      connection = joinVoiceChannel({
        channelId: userVoiceChannel.id,
        guildId: userVoiceChannel.guild.id,
        adapterCreator: userVoiceChannel.guild.voiceAdapterCreator,
      });
    } else {
      return;
    }
  }

  const stream = ytdl(youtubeUrl, {
    filter: "audioonly",
    quality: "highestaudio",
    highWaterMark: 1 << 27, // 25 MB m·∫∑c ƒë·ªãnh
    bitrate: 128,
  });

  const resource = createAudioResource(stream);
  player = createAudioPlayer();
  connection.subscribe(player);
  player.play(resource);

  isPlaying = true;

  player.on(AudioPlayerStatus.Idle, async () => {
    isPlaying = false;
    if (isLooping) {
      queue.unshift(youtubeUrl);
    }

    const embed = new EmbedBuilder()
      .setDescription("üéµ …¥ ú·∫°·¥Ñ ƒë√£ ·¥ã·∫ø·¥õ ·¥õ ú√∫·¥Ñ!")
      .setColor("#ff0000");

    const message = await textChannel.send({ embeds: [embed] });
    setTimeout(async () => {
      try {
        await message.delete();
      } catch (error) {}
    }, 5000);

    await playNextSong();
  });
}

// H√†m ph√°t b√†i ti·∫øp theo trong h√†ng ƒë·ª£i
async function playNextSong() {
  if (queue.length > 0) {
    const youtubeUrl = queue.shift();
    await playSpecificSong(youtubeUrl);
  } else {
    isPlaying = false;
    startIdleTimeout();
  }
}

//___
let is247Mode = false;

function startIdleTimeout() {
  if (idleTimeout) clearTimeout(idleTimeout);

  idleTimeout = setTimeout(async () => {
    if (!isPlaying && connection && !userRequestedLeave && !is247Mode) {
      connection.disconnect();
      connection = null;
      queue.length = 0;
      if (textChannel) {
        const embed = new EmbedBuilder()
          .setDescription(
            " ô·¥è·¥õ ƒë√£ ·¥õ·ª± ƒë·ªô…¥…¢  Ä·ªù…™ ·¥ã ú·ªè…™ ·¥†·¥è…™·¥Ñ·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü. \n \n- ·¥Ö·¥è ·¥ã ú√¥…¥…¢ ·¥ò ú√°·¥õ  ô√†…™ …¥ ú·∫°·¥Ñ …¥√†·¥è ·¥õ Ä·¥è…¥…¢ ùüπ ·¥ò ú√∫·¥õ. \n- ·¥õ Ä√°…¥ ú ·¥õ Ä·¥á·¥è  ô·¥è·¥õ …¥√™…¥ <@958668688607838208>  ü√†·¥ç …¥ ú∆∞ ·¥õ ú·∫ø …¥√† è.",
          )
          .setColor("#ff0000");

        await textChannel.send({ embeds: [embed] });
      }
    }
    userRequestedLeave = false;
  }, 180000); // 3 ph√∫t = 180000 ms
}

//___
async function handleUserLeaveRequest() {
  userRequestedLeave = true;
  if (connection) {
    connection.disconnect();
    connection = null;
    queue.length = 0;
  }
  if (idleTimeout) clearTimeout(idleTimeout);
  userRequestedLeave = false;
}

client.on("messageCreate", async (message) => {
  if (message.author.bot) return;
  lastBotMessage = message;

  const content = message.content.toLowerCase();

  const userVoiceChannel = message.member.voice.channel;
  textChannel = message.channel;

  if (
    content.startsWith("!joinv") ||
    content.startsWith("!jv") ||
    content.startsWith(`<@${client.user.id}> joinv`)
  ) {
    // Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ trong k√™nh voice kh√¥ng
    if (!userVoiceChannel) {
      const embed = new EmbedBuilder()
        .setDescription(" ô·∫°…¥ ·¥ò ú·∫£…™ ·¥†√†·¥è ·¥†·¥è…™·¥Ñ·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥õ Ä∆∞·ªõ·¥Ñ ·¥ã ú…™ ·¥Ö√π…¥…¢  ü·ªá…¥ ú …¥√† è!")
        .setColor("#ff0000");
      await message.channel.send({ embeds: [embed] });
      return;
    }

    connection = joinVoiceChannel({
      channelId: userVoiceChannel.id,
      guildId: userVoiceChannel.guild.id,
      adapterCreator: userVoiceChannel.guild.voiceAdapterCreator,
    });

    // Ph√°t √¢m thanh khi bot k·∫øt n·ªëi v√†o voice channel
    const joinSound = createAudioResource("girl-uwu.mp3");
    const joinPlayer = createAudioPlayer();
    connection.subscribe(joinPlayer);
    joinPlayer.play(joinSound);
    const embed = new EmbedBuilder()
      .setDescription(` ô·¥è·¥õ ƒë√£ ·¥õ ú·¥Ä·¥ç …¢…™·¥Ä ·¥ã√™…¥ ú: ${userVoiceChannel.name}`)
      .setColor("#00ff00");
    await message.channel.send({ embeds: [embed] });
    startIdleTimeout();
  }

  if (
    content.startsWith("!leavev") ||
    content.startsWith("!lv") ||
    content.startsWith(`<@${client.user.id}> leavev`)
  ) {
    if (connection) {
      connection.disconnect();
      connection = null;
      isPlaying = false;
      queue.length = 0;

      const embed = new EmbedBuilder()
        .setDescription(
          " ô·¥è·¥õ ƒë√£  Ä·ªù…™ ·¥†·¥è…™·¥Ñ·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü. \n \n- ·¥Ö√π…¥…¢  ü·ªá…¥ ú `/ ú·¥á ü·¥ò` ƒë·ªÉ  ô…™·∫ø·¥õ ·¥õ ú√™·¥ç.\n-  ô·¥è·¥õ ƒë√£ ·¥ú…¥ ü·¥è·¥Ñ·¥ã ·¥õ·∫•·¥õ ·¥Ñ·∫£ ·¥Ñ ú·ª©·¥Ñ …¥ƒÉ…¥…¢ ·¥ã ú√¥…¥…¢ ·¥Ñ·∫ß…¥ `·¥ò Ä·¥á·¥ç…™·¥ú·¥ç`.",
        )
        .setColor("#ff0000")
        .setFooter({ text: "¬© ·¥Ñ·¥è·¥Ö·¥á  ô è ·¥Ä…¥ ·¥ò·¥Ä ú…¥ üêß" })
        .setImage("https://share.creavite.co/664728aaaac1146a40c3c100.gif");

      await message.channel.send({ embeds: [embed] });
    } else {
      const embed = new EmbedBuilder()
        .setDescription(" ô·¥è·¥õ ·¥ã ú√¥…¥…¢ ·ªü ·¥õ Ä·¥è…¥…¢ ·¥†·¥è…™·¥Ñ·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü …¥√†·¥è.")
        .setColor("#ff0000");

      await message.channel.send({ embeds: [embed] });
    }
    handleUserLeaveRequest(); //
  }

  if (content.startsWith("!playnhac") || content.startsWith("!pn")) {
    const args = message.content.split(" ");
    const query = args.slice(1).join(" ");
    if (!query) {
      await message.channel.send(
        " ú√£ è …¥ ú·∫≠·¥ò ·¥ç·ªô·¥õ < ü…™…¥·¥ã>  ú·¥è·∫∑·¥Ñ <·¥õ√™…¥  ô√†…™  ú√°·¥õ>  ú·ª£·¥ò  ü·ªá.",
      );

      return;
    }

    const youtubeUrlPattern =
      /^https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[\w-]+|https?:\/\/(?:www\.)?youtu\.be\/[\w-]+/;
    const isYoutubeUrl = youtubeUrlPattern.test(query);

    if (!connection) {
      connection = joinVoiceChannel({
        channelId: userVoiceChannel.id,
        guildId: userVoiceChannel.guild.id,
        adapterCreator: userVoiceChannel.guild.voiceAdapterCreator,
      });

      const embed = new EmbedBuilder()
        .setDescription(` ô·¥è·¥õ ƒë√£ ·¥õ ú·¥Ä·¥ç …¢…™·¥Ä ·¥ã√™…¥ ú: ${userVoiceChannel.name}`)
        .setColor("#00ff00");
      await message.channel.send({ embeds: [embed] });
      startIdleTimeout();
    }
    if (isYoutubeUrl) {
      queue.push(query);
      const videoInfo = await ytdl.getInfo(query);
      const videoTitle = videoInfo.videoDetails.title;
      const videoAuthor = videoInfo.videoDetails.author.name;
      const videoDuration = videoInfo.videoDetails.lengthSeconds;
      const videoThumbnail = videoInfo.videoDetails.thumbnails[0].url;
      const videoUrl = "https://t.co/elon"; //
      const embed = new EmbedBuilder()
        .setDescription(
          `<:youtube:1243493337302962196> ƒê√£ ·¥õ ú√™·¥ç …¥ ú·∫°·¥Ñ:\n[_${videoTitle}_](${videoUrl})\n\n` +
          `<:heart:1269216504381968455> ·¥õ·∫°…™ ·¥ã√™…¥ ú:\n_${videoAuthor}_\n\n` +
          `<:heart:1269216504381968455> ùöÉùöë·ªùùöí ùôª∆∞·ª£ùöóùöê:\n_${Math.floor(videoDuration / 60)} ·¥ò ú√∫·¥õ : ${videoDuration % 60} …¢…™√¢ è_\n\n` +
          `<:heart:1269216504381968455> ùöà√™ùöû ùô≤·∫ßùöû ùô±·ªüùöí:\n<@${message.author.id}>`,
        )
        .setThumbnail(videoThumbnail)
        .setColor("#00ff00");

      await message.channel.send({ embeds: [embed] });

      if (!isPlaying) {
        await playNextSong();
      }
    } else {
      try {
        const results = await searchYouTube(query);

        const embed = new EmbedBuilder()
          .setTitle(`·¥Ö·¥Ä…¥ ú s√°·¥Ñ ú ·¥ã·∫ø·¥õ «´·¥ú·∫£ ·¥õ√¨·¥ç ·¥ã…™·∫ø·¥ç ·¥Ñ ú·¥è: ${query}`)
          .setColor("#00ff00");

        results.forEach((result, index) => {
          embed.addFields({
            name: `${index + 1} ‚Ä¢ **${result.title}**`,
            value: `_ ü…™…¥·¥ã …¥ ú·∫°·¥Ñ:_ ${result.link}`,
          });
        });

        const actionRow = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId("button1")
            .setLabel("1")
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId("button2")
            .setLabel("2")
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId("button3")
            .setLabel("3")
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId("button4")
            .setLabel("4")
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId("button5")
            .setLabel("5")
            .setStyle(ButtonStyle.Success),
        );

        const promptEmbed = new EmbedBuilder()
          .setDescription(" ô·∫•·¥ç ·¥†√†·¥è ·¥Ñ√°·¥Ñ …¥√∫·¥õ  ô√™…¥ ·¥Ö∆∞·ªõ…™ ƒë·ªÉ ·¥Ñ ú·ªç…¥ …¥ ú·∫°·¥Ñ!")
          .setColor("#00ff00");

        const replyMessage = await message.channel.send({
          embeds: [embed, promptEmbed],
          components: [actionRow],
        });

        const timeout = setTimeout(async () => {
          if (replyMessage) {
            try {
              await replyMessage.delete();
            } catch (error) {
              if (error.code !== 10008) {
              }
            }
          }

          const embed = new EmbedBuilder()
            .setDescription(
              "‚è± ƒê√£  ú·∫ø·¥õ ·¥õ ú·ªù…™ …¢…™·¥Ä…¥ ·¥Ñ ú·ªç…¥ …¥ ú·∫°·¥Ñ. ·¥†·¥ú…™  ü√≤…¥…¢ ·¥Ö√π…¥…¢  ü·∫°…™  ü·ªá…¥ ú !·¥ò ü·¥Ä è…¥ ú·¥Ä·¥Ñ.",
            )
            .setColor("#ff0000");

          await message.channel.send({ embeds: [embed] });
        }, 15000);

        const filter = (interaction) =>
          interaction.isButton() &&
          interaction.message.id === replyMessage.id &&
          interaction.user.id === message.author.id;
        const collector = message.channel.createMessageComponentCollector({
          filter,
          time: 15000,
        });

        collector.on("collect", async (interaction) => {
          collector.stop();
          const choiceIndex =
            parseInt(interaction.customId.replace("button", ""), 10) - 1;
          const chosenResult = results[choiceIndex];

          if (chosenResult && chosenResult.link) {
            queue.push(chosenResult.link);
            const videoInfo = await ytdl.getInfo(chosenResult.link);
            const videoTitle = videoInfo.videoDetails.title;
            const videoAuthor = videoInfo.videoDetails.author.name;
            const videoDuration = videoInfo.videoDetails.lengthSeconds;
            const videoThumbnail = videoInfo.videoDetails.thumbnails[0].url;
            const videoUrl = "https://t.co/elon"; //
            const embed = new EmbedBuilder()
              .setDescription(
                `<:youtube:1243493337302962196> ƒê√£ ·¥õ ú√™·¥ç …¥ ú·∫°·¥Ñ:\n[_${videoTitle}_](${videoUrl})\n\n` +
                `<:heart:1269216504381968455> ·¥õ·∫°…™ ·¥ã√™…¥ ú:\n_${videoAuthor}_\n\n` +
                `<:heart:1269216504381968455> ùöÉùöë·ªùùöí ùôª∆∞·ª£ùöóùöê:\n_${Math.floor(videoDuration / 60)} ·¥ò ú√∫·¥õ : ${videoDuration % 60} …¢…™√¢ è_\n\n` +
                `<:heart:1269216504381968455> ùöà√™ùöû ùô≤·∫ßùöû ùô±·ªüùöí:\n<@${message.author.id}>`,
              )
              .setThumbnail(videoThumbnail)
              .setColor("#00ff00");

            await message.channel.send({ embeds: [embed] });

            if (!isPlaying) {
              await playNextSong();
            }
          } else {
            await message.channel.send(
              "·¥ã ú√¥…¥…¢ ·¥õ√¨·¥ç ·¥õ ú·∫• è  ô√†…™  ú√°·¥õ ·¥ò ú√π  ú·ª£·¥ò. ·¥†·¥ú…™  ü√≤…¥…¢ ·¥õ ú·ª≠  ü·∫°…™.",
            );
          }

          if (replyMessage && replyMessage.deletable) {
            await replyMessage.delete();
          }
        });

        collector.on("end", async (collected, reason) => {
          if (reason === "time") {
            if (replyMessage) {
              try {
                await replyMessage.delete();
              } catch (error) {
                if (error.code !== 10008) {
                }
              }
            }
          }
          clearTimeout(timeout);
        });
      } catch (error) {
        await message.channel.send("ƒê√£ x·∫£ è  Ä·¥Ä  ü·ªó…™ ·¥ã ú…™ ·¥õ√¨·¥ç ·¥ã…™·∫ø·¥ç …¥ ú·∫°·¥Ñ.");
      }
    }
  }

  if (
    content.startsWith("!quabai") ||
    content.startsWith("!qb") ||
    content.startsWith(`<@${client.user.id}> quabai`)
  ) {
    if (queue.length > 0) {
      await playNextSong();
      const embed = new EmbedBuilder()
        .setDescription("ƒê√£ ·¥ò ú√°·¥õ  ô√†…™ …¥ ú·∫°·¥Ñ ·¥õ…™·∫ø·¥ò ·¥õ ú·¥á·¥è.")
        .setColor("#00ff00");
      await message.channel.send({ embeds: [embed] });
    } else {
      const embed = new EmbedBuilder()
        .setDescription("·¥ã ú√¥…¥…¢ ·¥Ñ√≥ …¥ ú·∫°·¥Ñ …¥√†·¥è ·¥õ Ä·¥è…¥…¢  ú√†…¥…¢ ƒë·ª£…™.")
        .setColor("#ff0000");
      await message.channel.send({ embeds: [embed] });
    }
  }

  if (
    content.startsWith("!dungnhac") ||
    content.startsWith("!dn") ||
    content.startsWith(`<@${client.user.id}> dungnhac`)
  ) {
    if (player) {
      player.pause();
      const embed = new EmbedBuilder()
        .setDescription("ƒê√£ ·¥Ö·ª´…¥…¢ …¥ ú·∫°·¥Ñ.")
        .setColor("#00ff00");
      await message.channel.send({ embeds: [embed] });
    } else {
      const embed = new EmbedBuilder()
        .setDescription("·¥ã ú√¥…¥…¢ ·¥Ñ√≥ …¥ ú·∫°·¥Ñ ƒë·¥Ä…¥…¢ ƒë∆∞·ª£·¥Ñ ·¥ò ú√°·¥õ.")
        .setColor("#ff0000");
      await message.channel.send({ embeds: [embed] });
    }
  }

  if (
    content.startsWith("!choitiep") ||
    content.startsWith("!ct") ||
    content.startsWith(`<@${client.user.id}> choitiep`)
  ) {
    if (player) {
      player.unpause();
      const embed = new EmbedBuilder()
        .setDescription("ƒë√£ ·¥ò ú√°·¥õ ·¥õ…™·∫ø·¥ò …¥ ú·∫°·¥Ñ.")
        .setColor("#00ff00");
      await message.channel.send({ embeds: [embed] });
    } else {
      const embed = new EmbedBuilder()
        .setDescription("·¥ã ú√¥…¥…¢ ·¥Ñ√≥ …¥ ú·∫°·¥Ñ ƒë·¥Ä…¥…¢ ƒë∆∞·ª£·¥Ñ ·¥ò ú√°·¥õ.")
        .setColor("#ff0000");
      await message.channel.send({ embeds: [embed] });
    }
  }

  if (
    content.startsWith("!laplainhac") ||
    content.startsWith("!lln") ||
    content.startsWith(`<@${client.user.id}> laplainhac`)
  ) {
    isLooping = !isLooping;
    const embed = new EmbedBuilder()
      .setDescription(` ü·∫∑·¥ò  ü·∫°…™ …¥ ú·∫°·¥Ñ | ƒë√£ ${isLooping ? "B·∫≠t" : "T·∫Øt"}.`)
      .setColor(isLooping ? "#00ff00" : "#ff0000");
    await message.channel.send({ embeds: [embed] });
  }

  if (
    content.startsWith("!247") ||
    content.startsWith(`<@${client.user.id}> 247`)
  ) {
    is247Mode = !is247Mode;
    const status = is247Mode ? "B·∫≠t" : "T·∫Øt";
    const embed = new EmbedBuilder()
      .setDescription(`·¥Ñ ú·∫ø ƒë·ªô ·¥õ Ä·¥á·¥è ùü∏ùü∫/ùüΩ | ƒë√£ ${status}.`)
      .setColor(is247Mode ? "#00ff00" : "#ff0000");
    await message.channel.send({ embeds: [embed] });
  }
});

//___

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  const { commandName } = interaction;

  if (commandName === "quetpl") {
    const pluginAttachment = interaction.options.getAttachment("plugin");

    if (!pluginAttachment.name.endsWith(".jar")) {
      await interaction.reply({
        content: "‚ùå ·¥†·¥ú…™  ü√≤…¥…¢ …¢·ª≠…™ “ì…™ ü·¥á ·¥ò ü·¥ú…¢…™…¥ ·¥Ö·∫°…¥…¢ (.·¥ä·¥Ä Ä).",
        ephemeral: true,
      });
      return;
    }

    if (!allowedUserIds.includes(interaction.user.id)) {
      await interaction.reply({
        embeds: [
          new EmbedBuilder()
            .setColor("#ff0000")
            .setTitle("‚ö†Ô∏è «´·¥ú è·ªÅ…¥  ú·∫°…¥ ·¥ã ú√¥…¥…¢ ƒë·ªß ‚ö†Ô∏è")
            .setDescription("‚ùé  ô·∫°…¥ ·¥ã ú√¥…¥…¢ ·¥Ñ√≥ «´·¥ú è·ªÅ…¥ s·ª≠ ·¥Ö·ª•…¥…¢  ü·ªá…¥ ú …¥√† è."),
        ],
        ephemeral: true,
      });
      return;
    }

    const initialReply = await interaction.reply({
      embeds: [
        new EmbedBuilder()
          .setColor("#0099ff")
          .setDescription(
            "ƒê·¥Ä…¥…¢ «´·¥ú√©·¥õ “ì…™ ü·¥á, ·¥†·¥ú…™  ü√≤…¥…¢ ƒë·ª£…™ <a:loadingma:1265977725559111710>\n·¥Ñ√≥ ·¥õ ú·ªÉ ·¥ç·∫•·¥õ ·¥õ·ª´ ùüπ-ùüª ·¥ò ú√∫·¥õ ƒë·ªÉ «´·¥ú√©·¥õ x·¥è…¥…¢!",
          ),
      ],
      ephemeral: false,
      fetchReply: true,
    });

    try {
      const response = await fetch(pluginAttachment.url);
      const arrayBuffer = await response.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);

      const formData = new FormData();
      formData.append("file", buffer, { filename: pluginAttachment.name });

      const options = {
        method: "POST",
        url: "https://www.virustotal.com/api/v3/files",
        headers: {
          accept: "application/json",
          "x-apikey": process.env.VIRUSTOTAL_API_KEY,
          ...formData.getHeaders(),
        },
        data: formData,
      };

      const uploadResponse = await axios.request(options);
      const fileId = uploadResponse.data.data.id;

      const checkScanStatus = async (fileId) => {
        const scanOptions = {
          method: "GET",
          url: `https://www.virustotal.com/api/v3/analyses/${fileId}`,
          headers: {
            accept: "application/json",
            "x-apikey": process.env.VIRUSTOTAL_API_KEY,
          },
        };

        let scanResponse;
        let completed = false;

        while (!completed) {
          scanResponse = await axios.request(scanOptions);
          if (scanResponse.data.data.attributes.status === "completed") {
            completed = true;
          } else {
            await new Promise((resolve) => setTimeout(resolve, 2000));
          }
        }
        return scanResponse.data;
      };

      const scanResult = await checkScanStatus(fileId);
      const results = scanResult.data.attributes.results;
      const detections = [];

      for (const engine in results) {
        if (results[engine].category === "malicious") {
          detections.push(`${engine}: ${results[engine].result}`);
        }
      }

      let embedResult;
      if (detections.length > 0) {
        embedResult = new EmbedBuilder()
          .setColor("#ff0000")
          .setDescription(
            `·¥ã·∫ø·¥õ «´·¥ú·∫£ «´·¥ú√©·¥õ “ì…™ ü·¥á: **${pluginAttachment.name}**\n\n·¥Ñ ú∆∞∆°…¥…¢ ·¥õ Ä√¨…¥ ú ƒë·ªô·¥Ñ  ú·∫°…™ ƒë∆∞·ª£·¥Ñ ·¥ò ú√°·¥õ  ú…™·ªá…¥:\n\`\`\`${detections.join("\n")}\`\`\``,
          )
          .setFooter({ text: "¬© s·¥Ñ·¥Ä…¥ ·¥†…™ Ä·¥ús ·¥Ä·¥õ úüêß" })
          .setTimestamp();
      } else {
        embedResult = new EmbedBuilder()
          .setColor("#00ff00")
          .setDescription(
            `·¥ã·∫ø·¥õ «´·¥ú·∫£ «´·¥ú√©·¥õ “ì…™ ü·¥á: **${pluginAttachment.name}**\n\n\`\`\`·¥ã ú√¥…¥…¢ ·¥ò ú√°·¥õ  ú…™·ªá…¥ ·¥Ñ ú∆∞∆°…¥…¢ ·¥õ Ä√¨…¥ ú ƒë·ªô·¥Ñ  ú·∫°…™ …¥√†·¥è.\`\`\``,
          )
          .setFooter({ text: "¬© s·¥Ñ·¥Ä…¥ ·¥†…™ Ä·¥ús ·¥Ä·¥õ úüêß" })
          .setTimestamp();
      }

      await interaction.editReply({ embeds: [embedResult] });
    } catch (err) {
      console.error(err);
      await interaction.editReply({
        content: ` ü·ªó…™ ·¥ã ú…™ «´·¥ú√©·¥õ “ì…™ ü·¥á. ·¥Ñ ú…™ ·¥õ…™·∫ø·¥õ: \`${err.message}\``,
        embeds: [],
        ephemeral: true,
      });
    }
  }
});

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  const { commandName } = interaction;

  if (commandName === "quetlink") {
    const url = interaction.options.getString("url");

    if (!url) {
      await interaction.reply({
        embeds: [
          new EmbedBuilder()
            .setColor("#ff0000")
            .setDescription("·¥†·¥ú…™  ü√≤…¥…¢ …¥ ú·∫≠·¥ò ·¥ú Ä ü ƒë·ªÉ «´·¥ú√©·¥õt."),
        ],
        ephemeral: true,
      });
      return;
    }

    const embedScanning = new EmbedBuilder()
      .setColor("#0099ff")
      .setDescription(
        "ƒê·¥Ä…¥…¢ «´·¥ú√©·¥õ ·¥ú Ä ü, ·¥†·¥ú…™  ü√≤…¥…¢ ƒë·ª£…™ <a:loadingma:1265977725559111710>\n·¥Ñ√≥ ·¥õ ú·ªÉ ·¥ç·∫•·¥õ ·¥õ·ª´ ùüπ-ùüª ·¥ò ú√∫·¥õ ƒë·ªÉ «´·¥ú√©·¥õ x·¥è…¥…¢!",
      );

    await interaction.reply({ embeds: [embedScanning], ephemeral: false });

    try {
      const options = {
        method: "POST",
        url: "https://www.virustotal.com/api/v3/urls",
        headers: {
          accept: "application/json",
          "x-apikey": process.env.VIRUSTOTAL_API_KEY,
          "Content-Type": "application/x-www-form-urlencoded",
        },
        data: `url=${encodeURIComponent(url)}`,
      };

      const response = await axios.request(options);
      const scanId = response.data.data.id;

      const checkScanStatus = async (scanId) => {
        const statusOptions = {
          method: "GET",
          url: `https://www.virustotal.com/api/v3/analyses/${scanId}`,
          headers: {
            accept: "application/json",
            "x-apikey": process.env.VIRUSTOTAL_API_KEY,
          },
        };

        let scanResponse;
        let completed = false;

        while (!completed) {
          scanResponse = await axios.request(statusOptions);
          if (scanResponse.data.data.attributes.status === "completed") {
            completed = true;
          } else {
            await new Promise((resolve) => setTimeout(resolve, 2000));
          }
        }

        return scanResponse.data;
      };

      const scanResult = await checkScanStatus(scanId);
      const results = scanResult.data.attributes.results;
      const detections = [];

      for (const engine in results) {
        if (results[engine].category === "malicious") {
          detections.push(`${engine}: ${results[engine].result}`);
        }
      }

      if (detections.length > 0) {
        embedScanning
          .setColor("#ff0000")
          .setDescription(
            `·¥ã·∫ø·¥õ «´·¥ú·∫£ «´·¥ú√©·¥õ ·¥ú Ä ü: **${url}**\n\n·¥ò ú√°·¥õ  ú…™·ªá…¥ ·¥Ñ√°·¥Ñ ·¥ò ú·∫ß…¥ ·¥ç·ªÅ·¥ç ƒë·ªô·¥Ñ h·∫°i:\n\`\`\`${detections.join("\n")}\`\`\``,
          )
          .setFooter({ text: "¬© s·¥Ñ·¥Ä…¥ ·¥†…™ Ä·¥ús ·¥Ä·¥õ úüêß" })
          .setTimestamp();
      } else {
        embedScanning
          .setColor("#00ff00")
          .setDescription(
            `·¥ã·∫ø·¥õ «´·¥ú·∫£ «´·¥ú√©·¥õ ·¥ú Ä ü: **${url}**\n\n\`\`\`·¥ã ú√¥…¥…¢ ·¥ò ú√°·¥õ  ú…™·ªá…¥ ·¥ò ú·∫ß…¥ ·¥ç·ªÅ·¥ç ƒë·ªô·¥Ñ  ú·∫°…™.\`\`\``,
          )
          .setFooter({ text: "¬© s·¥Ñ·¥Ä…¥ ·¥†…™ Ä·¥ús ·¥Ä·¥õ úüêß" })
          .setTimestamp();
      }

      await interaction.editReply({ embeds: [embedScanning] });
    } catch (err) {
      console.error(err);
      await interaction.editReply({
        embeds: [
          embedScanning
            .setColor("#ff0000")
            .setDescription(` ü·ªó…™ ·¥ã ú…™ «´·¥ú√©·¥õ ·¥ú Ä ü. ·¥Ñ ú…™ ·¥õ…™·∫ø·¥õ: \`${err.message}\``),
        ],
      });
    }
  }
});
//___

client.on('interactionCreate', async interaction => {
    if (!interaction.isCommand()) return;

    if (interaction.commandName === 'check') {
        const guildId = interaction.options.getString('id') || interaction.guild.id;

        try {
            const guild = await client.guilds.fetch(guildId);
            
            const securityEmbed = new EmbedBuilder()
                .setTitle('üîí ùë∫ùíÜùíÑùíñùíìùíäùíïùíö ùë™ùíâùíÜùíÑùíå')
                .setColor('#FF0000')
                .setDescription(`·¥ã…™·ªÉ·¥ç ·¥õ Ä·¥Ä  ô·∫£·¥è ·¥ç·∫≠·¥õ ·¥Ñ ú·¥è ·¥ç√° è ·¥Ñ ú·ªß **${guild.name}**`)
                .setThumbnail(guild.iconURL())
                .setTimestamp();

            const is2FAEnabled = guild.mfaLevel === 1 ? '·¥Ñ√≥' : '·¥ã ú√¥…¥…¢';
            securityEmbed.addFields([{ name: 'ùü∏“ì·¥Ä ·¥Ñ ú·¥è «´·¥ú·∫£…¥ ·¥õ Ä·ªã ·¥†…™√™…¥:', value: is2FAEnabled }]);

          let adminRoles = guild.roles.cache.filter(role => role.permissions.has(PermissionsBitField.Flags.Administrator));
securityEmbed.addFields([{ 
    name: '·¥†·¥Ä…™ ·¥õ Ä√≤ ·¥Ñ√≥ «´·¥ú è·ªÅ…¥ «´·¥ú·∫£…¥ ·¥õ Ä·ªã:', 
    value: adminRoles.size > 0 ? `\`\`\`${adminRoles.map(role => role.name).join(', ')}\`\`\`` : '·¥ã ú√¥…¥…¢ ·¥Ñ√≥' 
}]);

let botWithAdmin = guild.members.cache.filter(member => member.user.bot && member.permissions.has(PermissionsBitField.Flags.Administrator));
securityEmbed.addFields([{ 
    name: ' ô·¥è·¥õ ·¥Ñ√≥ «´·¥ú è·ªÅ…¥ «´·¥ú·∫£…¥ ·¥õ Ä·ªã:', 
    value: botWithAdmin.size > 0 ? `\`\`\`${botWithAdmin.map(member => member.user.username).join(', ')}\`\`\`` : '·¥ã ú√¥…¥…¢ ·¥Ñ√≥' 
}]);

            const contentFilterLevels = ['·¥õ·∫Ø·¥õ', '·¥Ñ ú·ªâ «´·¥ú√©·¥õ ·¥õ ú√†…¥ ú ·¥†…™√™…¥ ·¥ã ú√¥…¥…¢ ·¥Ñ√≥ ·¥†·¥Ä…™ ·¥õ Ä√≤', '«´·¥ú√©·¥õ ·¥õ·∫•·¥õ ·¥Ñ·∫£ ·¥õ ú√†…¥ ú ·¥†…™√™…¥'];
            const verificationLevels = ['·¥ã ú√¥…¥…¢ ·¥Ñ√≥', ' è√™·¥ú ·¥Ñ·∫ß·¥ú ·¥á·¥ç·¥Ä…™ ü', ' è√™·¥ú ·¥Ñ·∫ß·¥ú ƒëƒÉ…¥…¢ ·¥ã√Ω ·¥õ Ä√™…¥ ·¥Ö…™s·¥Ñ·¥è Ä·¥Ö ·¥õ Ä√™…¥ ùüª ·¥ò ú√∫·¥õ', ' è√™·¥ú ·¥Ñ·∫ß·¥ú  ü√† ·¥õ ú√†…¥ ú ·¥†…™√™…¥ ·¥õ Ä√™…¥ ùü∑ùü∂ ·¥ò ú√∫·¥õ', ' è√™·¥ú ·¥Ñ·∫ß·¥ú x√°·¥Ñ ·¥ç…™…¥ ú «´·¥ú·¥Ä s·ªë ƒë…™·ªá…¥ ·¥õ ú·¥è·∫°…™'];

            securityEmbed.addFields([
              { name: ' ô·ªô  ü·ªç·¥Ñ …¥·ªô…™ ·¥Ö·¥ú…¥…¢:', value: contentFilterLevels[guild.explicitContentFilter], inline: true },
              { name: '·¥ç·ª©·¥Ñ ƒë·ªô x√°·¥Ñ ·¥ç…™…¥ ú:', value: verificationLevels[guild.verificationLevel], inline: true },
              { name: 's·ªë  ü∆∞·ª£…¥…¢ ·¥õ ú√†…¥ ú ·¥†…™√™…¥:', value: `${guild.memberCount}`, inline: true },
              { name: 's·ªë  ü∆∞·ª£…¥…¢ ·¥ã√™…¥ ú:', value: `${guild.channels.cache.size}`, inline: true },
            ]);

            await interaction.reply({ embeds: [securityEmbed] });
        } catch (error) {
            if (error.code === 10004) {
                await interaction.reply(`·¥ã ú√¥…¥…¢ ·¥õ√¨·¥ç ·¥õ ú·∫• è ·¥ç√° è ·¥Ñ ú·ªß ·¥†·ªõ…™ …™·¥Ö: "${guildId}"`);
            } else if (error.code === 50001) {
                await interaction.reply(' ô·¥è·¥õ ·¥ã ú√¥…¥…¢ ·¥Ñ√≥ «´·¥ú è·ªÅ…¥ ·¥õ Ä·¥ú è ·¥Ñ·∫≠·¥ò ·¥õ ú√¥…¥…¢ ·¥õ…™…¥ ·¥Ñ·ªß·¥Ä ·¥ç√° è ·¥Ñ ú·ªß …¥√† è.');
            } else {
                await interaction.reply('ƒê√£ x·∫£ è  Ä·¥Ä  ü·ªó…™ ·¥ã ú…™ x·ª≠  ü√Ω  è√™·¥ú ·¥Ñ·∫ß·¥ú.');
                console.error(error);
            }
        }
    }
});
//___

client.on('interactionCreate', async interaction => {
    if (!interaction.isCommand()) return;

    if (interaction.commandName === 'nasa') {
        try {
      
            const response = await axios.get(`https://api.nasa.gov/planetary/apod?api_key=${process.env.NASA_API_KEY}`);
            const apod = response.data;

            const nasaEmbed = new EmbedBuilder()
                .setTitle(apod.title)
                .setDescription(apod.explanation)
                .setImage(apod.url)
                .setFooter({ text: `Ng√†y: ${apod.date}` });

            await interaction.reply({ embeds: [nasaEmbed] });
        } catch (error) {
            console.error(error);
            await interaction.reply('Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ NASA.');
        }
    }
});
//___

client.on('interactionCreate', async (interaction) => {
  if (!interaction.isCommand()) return;

  if (interaction.commandName === 'info') {
    let targetUser = interaction.options.getUser('user');

    // N·∫øu kh√¥ng c√≥ user, th√¨ ki·ªÉm tra ch√≠nh ng∆∞·ªùi g·ªçi l·ªánh
    if (!targetUser) {
      targetUser = interaction.user;
    }

    const member = interaction.guild.members.cache.get(targetUser.id);
    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle('T ú√¥…¥…¢ ·¥õ…™…¥ ·¥Ñ√° …¥ ú√¢…¥:')
      .setThumbnail(targetUser.displayAvatarURL({ dynamic: true }))
      .addFields(
        { name: '·¥õ√™…¥ …¥…¢∆∞·ªù…™ ·¥Ö√π…¥…¢:', value: targetUser.username, inline: true },
        { name: 'ID:', value: `\`${targetUser.id}\``, inline: true },
        {
          name: '…¥…¢√† è ·¥õ ú·¥Ä·¥ç …¢…™·¥Ä Discord:',
          value: targetUser.createdAt.toLocaleDateString('en-US'),
          inline: true,
        },
      );

    if (member) {
      embed.addFields(
        {
          name: '…¥…¢√† è ·¥õ ú·¥Ä·¥ç …¢…™·¥Ä Server:',
          value: member.joinedAt.toLocaleDateString('en-US'),
          inline: true,
        },
        {
  name: '·¥†·¥Ä…™ ·¥õ Ä√≤:',
  value: `\`\`\`${member.roles.cache.map((role) => role.name).join(', ')}\`\`\``,
  inline: true,
},
        {
          name: '·¥õ Ä·∫°…¥…¢ ·¥õ ú√°…™:',
          value: member.presence ? member.presence.status : 'Offline',
          inline: true,
        },
      );
    }

    await interaction.reply({ embeds: [embed] });
  }
});


//___logins v√†o bot
client.login(process.env.token);